# Contains the function Renyi_SDP
# Code is based on code found in https://github.com/peterjbrown519/DI-rates and contains definitions found in https://github.com/peterjbrown519/ncpol2sdpa to extract the NPA Relaxation

def generate_quadrature(m,beta):
    """
    Generates the Gaussian quadrature nodes t and weights w. Due to the way the
    package works it generates M nodes and weights.
        m    --    number of nodes in quadrature
    """
    t, w = scipy.special.roots_jacobi(m, 1-beta, beta-1,mu=False)
    t[m-1] = 1
    w[m-1] = ((scipy.special.gamma(2-beta)*scipy.special.gamma(m)*scipy.special.gamma(3-beta))/(scipy.special.gamma(m+2-beta)))*(scipy.special.gamma(m+beta-1)/scipy.special.gamma(m+1))
    mrange = m-1
    for i in range(mrange):
        ts2, ws2 = scipy.special.roots_jacobi(m-1, 2-beta, beta-1,mu=False)
        t[i] = ts2[i]
        w[i] = (1/2)*(1/(m+1-beta))*((scipy.special.gamma(m+beta-1)*scipy.special.gamma(m+1-beta))/(scipy.special.gamma(m)*scipy.special.gamma(m+1)))*((1+t[i])/(scipy.special.eval_jacobi(m-1,beta-1,1-beta,-t[i])**2))     
        
    
    return t, w

def objective(A,B,Z, T1, W1,M):
    """
    Returns the objective function: Tr[rho(M_{0|0}\otimes N_{0|0} \otimes P(Z,Z')+M_{1|0}\otimes N_{1|0} \otimes Q(Z,Z'))]
    where P = 2*v*Z^\dagger*Z + v'*(t'+1)*(Z'+Z'^\dagger)+v'*(t'+1)*Z'^\dagger*Z'
    Q = 2*v'*Z'*Z'^\dagger + v*(t+1)*(Z+Z^\dagger)+v*(t+1)*Z*Z^\dagger
    Note that in "compute_entropy", this quantity will later be multiplied by sin(alpha*pi)/(pi*p(00|00)) 
    and one must add a constant sin(alpha*pi)/(pi)*[v'*(t'+1)+v*(t+1)]
    """
    obj = 0.0
    #cm = 0.0
    F = [A[0][0], 1-A[0][0]]
    G = [B[0][0], 1-B[0][0]]
    mrange = M    
    for i in range(mrange):
        ti = T1[i]
        wi = W1[i]   
        
        for a in range(len(F)): 
            obj += F[a]*(((2*wi)/(1+ti))*(1+Z[i][a]+Dagger(Z[i][a])+((1-ti)/2)*Dagger(Z[i][a])*Z[i][a]))
            obj += wi*Z[i][a]*Dagger(Z[i][a])  
    return obj

def score_constraints(sys, Aops, Bops, eta=1.0):
    """
    Returns moment equality constraints generated by the two-qubit system specified by sys.
    In particular implements the constraints p(00|xy) and p(0|x), p(0|y) for each x,y.
        sys --  parameterization of two qubit system [theta, a0, a1, b0, b1]
                where state is
                                cos(theta) |00> + sin(theta) |11>
                and measurements are given by projectors
                                (id + cos(x) sz + sin(x) sx)/2
                defined by the remaining angles in sys with sz and sx being the Pauli z
                and Pauli x matrices.
        Aops -- Operators for Alice
        Bops -- Operators for Bob
        eta  -- Detection efficiency
    """

    [id, sx, sy, sz] = [qtp.qeye(2), qtp.sigmax(), qtp.sigmay(), qtp.sigmaz()]
    [theta, a0, a1, b0, b1] = sys[:]
    # Assume a pure two-qubit state of |00> + |11> form
    rho = (cos(theta)*qtp.ket('00') + sin(theta)*qtp.ket('11')).proj()

    # Define the projectors for each of the measurements of Alice and Bob
    a00 = 0.5*(id + cos(a0)*sz + sin(a0)*sx)
    a01 = id - a00
    a10 = 0.5*(id + cos(a1)*sz + sin(a1)*sx)
    a11 = id - a10
    b00 = 0.5*(id + cos(b0)*sz + sin(b0)*sx)
    b01 = id - b00
    b10 = 0.5*(id + cos(b1)*sz + sin(b1)*sx)
    b11 = id - b10

    A_meas = [[a00, a01], [a10, a11]]
    B_meas = [[b00, b01], [b10, b11]]

    # Now collect the constraints subject to the inefficient detection distribution
    constraints = []
    # Constraints of form p(00|xy)
    for x in range(2):
        for y in range(2):
            constraints += [Aops[x][0]*Bops[y][0] - (eta * (rho*qtp.tensor(A_meas[x][0], B_meas[y][0])).tr().real
            + (1-eta)/4)]
    # Marginal constraints
    constraints += [Aops[0][0] - (eta) * (rho*qtp.tensor(A_meas[0][0], id)).tr().real - (1-eta)/2]
    constraints += [Bops[0][0] - (eta) * (rho*qtp.tensor(id, B_meas[0][0])).tr().real - (1-eta)/2]
    constraints += [Aops[1][0] - (eta) * (rho*qtp.tensor(A_meas[1][0], id)).tr().real - (1-eta)/2]
    constraints += [Bops[1][0] - (eta) * (rho*qtp.tensor(id, B_meas[1][0])).tr().real - (1-eta)/2]

    return constraints[:]

def sys2vec(sys, eta = 1.0):
    """
    Returns vector of probabilities p(00|xy), p(0|x), p(0|y) associated with sys in the same order
    as the constraints are specified in score_constraints function.
        sys --  parameterization of two qubit system [theta, a0, a1, b0, b1]
                where state is
                                cos(theta) |00> + sin(theta) |11>
                and measurements are given by projectors
                                (id + cos(x) sz + sin(x) sx)/2
                defined by the remaining angles in sys with sz and sx being the Pauli z
                and Pauli x matrices.
        eta  -- Detection efficiency
    """
    [id, sx, sy, sz] = [qtp.qeye(2), qtp.sigmax(), qtp.sigmay(), qtp.sigmaz()]
    [theta, a0, a1, b0, b1] = sys[:]
    rho = (cos(theta)*qtp.ket('00') + sin(theta)*qtp.ket('11')).proj()

    # Define the projectors for each of the measurements of Alice and Bob
    a00 = 0.5*(id + cos(a0)*sz + sin(a0)*sx)
    a01 = id - a00
    a10 = 0.5*(id + cos(a1)*sz + sin(a1)*sx)
    a11 = id - a10
    b00 = 0.5*(id + cos(b0)*sz + sin(b0)*sx)
    b01 = id - b00
    b10 = 0.5*(id + cos(b1)*sz + sin(b1)*sx)
    b11 = id - b10

    A_meas = [[a00, a01], [a10, a11]]
    B_meas = [[b00, b01], [b10, b11]]

    # Now collect the vector
    vec = []
    for x in range(2):
        for y in range(2):
            vec += [(eta * (rho*qtp.tensor(A_meas[x][0], B_meas[y][0])).tr().real 
                        + (1-eta)/4)]

    vec += [eta * (rho*qtp.tensor(A_meas[0][0], id)).tr().real + (1-eta)/2]
    vec += [eta * (rho*qtp.tensor(id, B_meas[0][0])).tr().real + (1-eta)/2]
    vec += [eta * (rho*qtp.tensor(A_meas[1][0], id)).tr().real + (1-eta)/2]
    vec += [eta * (rho*qtp.tensor(id, B_meas[1][0])).tr().real + (1-eta)/2]

    return vec       

def get_subs(A,B,Z):
    """
    Returns any substitution rules to use with ncpol2sdpa. E.g. projections and
    commutation relations.
    """
    subs = {}
    # Get Alice and Bob's projective measurement constraints
    subs.update(ncp.projective_measurement_constraints(A,B))

    # Finally we note that Alice and Bob's operators should All commute with Eve's ops
    for a in ncp.flatten([A,B]):
        for z in ncp.flatten(Z):
            subs.update({z*a : a*z, Dagger(z)*a : a*Dagger(z)})

    return subs

def get_extra_monomials(A,B,Z):
    """
    Returns additional monomials to add to sdp relaxation.
    """

    monos = []

    return monos[:]

def get_local_level(A,B,Z,k):

    monos = []

    # Add ABZ
    ZZ = ncp.get_monomials(ncp.flatten(Z), k)
    AA = ncp.get_monomials(ncp.flatten(A), k)
    BB = ncp.get_monomials(ncp.flatten(B), k)

    for a in AA:
        for b in BB:
            for z in ZZ:
                monos += [a*b*z]

    return monos[:]

def compute_entropy(SDP, alpha, test_sys, test_eta):
    """
    """
    const = 0.0        # constant term
    
    ent = 0.0        # lower bound on Tr[rho^alpha sigma^1-alpha]
    score_constr = sys2vec(test_sys, test_eta)
    c = sin(alpha*pi)/(pi)

    SDP.solve('mosek')
        # print(sdp.status)

    if SDP.status == 'optimal':
        # 1 contributes to the constant term
        ent = (1/(1-alpha))*log2(1 + c*SDP.dual)
    else:
        # If we didn't solve the SDP well enough then just bound the entropy
        # trivially
        ent = 0
        if VERBOSE:
            print('Bad solve: ', SDP.status)

    return ent


def convert_row_to_sdpa_index(block_struct, row_offsets, row):
    """Helper function to map to sparse SDPA index values.
    """
    block_index = bisect_left(row_offsets[1:], row + 1)
    width = block_struct[block_index]
    row = row - row_offsets[block_index]
    i, j = divmod(row, width)
    return block_index, i, j


def convert_to_cvxpy(sdp):
    """Convert an SDP relaxation to a CVXPY problem.

    :param sdp: The SDP relaxation to convert.
    :type sdp: :class:`ncpol2sdpa.sdp`.

    :returns: :class:`cvxpy.Problem`.
    """
    #from cvxpy import Minimize, Problem, Variable
    import cvxpy as cp
    
    row_offsets = [0]
    cumulative_sum = 0
    for block_size in sdp.block_struct:
        cumulative_sum += block_size ** 2
        row_offsets.append(cumulative_sum)
    x = cp.Variable(sdp.n_vars)
    # The moment matrices are the first blocks of identical size
    constraints = []
    for idx, bs in enumerate(sdp.block_struct):
        nonzero_set = set()
        F = [lil_matrix((bs, bs)) for _ in range(sdp.n_vars+1)]
        for ri, row in enumerate(sdp.F.rows[row_offsets[idx]:
                                            row_offsets[idx+1]],
                                 row_offsets[idx]):
            block_index, i, j = convert_row_to_sdpa_index(sdp.block_struct,
                                                          row_offsets, ri)
            for col_index, k in enumerate(row):
                value = sdp.F.data[ri][col_index]
                F[k][i, j] = value
                F[k][j, i] = value
                nonzero_set.add(k)
        if bs > 1:
            sum_ = sum(F[k]*x[k-1] for k in nonzero_set if k > 0)
            if not isinstance(sum_, (int, float)):
                if F[0].getnnz() > 0:
                    sum_ += F[0]
                constraints.append(sum_ >> 0)
        else:
            sum_ = sum(F[k][0, 0]*x[k-1] for k in nonzero_set if k > 0)
            if not isinstance(sum_, (int, float)):
                sum_ += F[0][0, 0]
                constraints.append(sum_ >= 0)
    obj = sum(ci*xi for ci, xi in zip(sdp.obj_facvar, x) if ci != 0)
    problem = cp.Problem(cp.Minimize(obj), constraints)
    return x,obj,constraints


def convert_monomial_to_string(monomial):
    monomial_str = ('%s' % monomial)
    monomial_str = monomial_str.replace('Dagger(', '')
    monomial_str = monomial_str.replace(')', 'T')
    monomial_str = monomial_str.replace('**', '^')
    return monomial_str

import numpy as np
import scipy
from math import sqrt, log2, log, pi, cos, sin
import ncpol2sdpa as ncp
from sympy.physics.quantum.dagger import Dagger
import mosek
import chaospy
import qutip as qtp

from bisect import bisect_left
from scipy.sparse import lil_matrix

def Renyi_SDP(beta1, A_config, B_config, LEVEL, M):

    #LEVEL = 1                       # NPA relaxation level
    #M = 10                     # Number of nodes in gaussian quadrature
    alpha = 1+beta1            # Choose alpha for Petz-Renyi entropy
    T1, W1 = generate_quadrature(M,alpha)    # Set 1: Nodes, weights of quadrature
    KEEP_M = 1                        # Optimizing mth objective function?
    VERBOSE = 2                        # If > 1 then ncpol2sdpa will also be verbose
    
    # Description of Alice and Bobs devices (each input has 2 outputs)
    #A_config = [2,2]
    #B_config = [2,2]
    
    # Operators in the problem Alice, Bob and Eve
    A = [Ai for Ai in ncp.generate_measurements(A_config, 'A')]
    B = [Bj for Bj in ncp.generate_measurements(B_config, 'B')]
    if KEEP_M:
        Z = [ncp.generate_operators('Z'+str(k), 2, hermitian=0) for k in range(M)]
    else:
        Z = [ncp.generate_operators('Z'+str(k), 2, hermitian=0) for k in range(M-1)]
    
    
    substitutions = {}            # substitutions to be made (e.g. projections)
    moment_ineqs = []            # Moment inequalities (e.g. Tr[rho CHSH] >= c)
    moment_eqs = []                # Moment equalities (not needed here)
    op_eqs = []                    # Operator equalities (not needed here)
    op_ineqs = []                # Operator inequalities (e.g. Id - A00 >= 0 -- we don't include for speed)
    extra_monos = []            # Extra monomials to add to the relaxation beyond the level.
    
    
    # Get the relevant substitutions
    substitutions = get_subs(A,B,Z)
    
    # Define the moment equality constraints given by the distribution induced by sys and eta
    #test_sys = [pi/4, 0, pi/2, pi/4, 3*pi/4]
    #test_eta = 0.8
    #score_cons = score_constraints(test_sys, A, B, test_eta)
    
    
    # Get any extra monomials we wanted to add to the problem
    extra_monos = get_extra_monomials(A,B,Z) + get_local_level(A,B,Z,1)
    
    # Define the objective function (changed later)
    obj = objective(A,B, Z,T1, W1,M)

    
    
    # Finally defining the sdp relaxation in ncpol2sdpa
    ops = ncp.flatten([A,B,Z])
    sdp = ncp.SdpRelaxation(ops, verbose = VERBOSE-1, normalized=True, parallel=0)
    sdp.get_relaxation(level = LEVEL,
        equalities = op_eqs[:],
        inequalities = op_ineqs[:],
        momentequalities = moment_eqs[:],
        momentinequalities = moment_ineqs[:],
        objective = obj,
        substitutions = substitutions,
        extramonomials = extra_monos)
    
    # Test
    #ent = compute_entropy(sdp, alpha,test_sys, test_eta)
    #print(ent)
    [x,obj,constraints] = convert_to_cvxpy(sdp)
    
    monomials = []

    for key, v in sdp.monomial_index.items():
        monomials += [convert_monomial_to_string(key)]
        
        
    
    return [x,obj+sdp.constant_term,constraints,monomials]
