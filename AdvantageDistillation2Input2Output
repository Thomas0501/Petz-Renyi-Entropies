# Code is based on code found in https://github.com/peterjbrown519/DI-rates
# Requires ncpol2sdpa package

def generate_quadrature(m,beta):
    """
    Generates the Gaussian quadrature nodes t and weights w. Due to the way the
    package works it generates M nodes and weights.
        m    --    number of nodes in quadrature
    """
    # Nodes will be appropriately changed from [-1,1] to [0,1]
    t1, w1 = scipy.special.roots_jacobi(m, 0, beta-1,mu=False)
    w1 = w1*(2**(-beta))
    t2, w2 = scipy.special.roots_jacobi(m, 0, -beta,mu=False)
    w2= w2*(2**(beta-1))
        
    
    return t1, w1, t2, w2


def score_constraints(sys, Aops, Bops, eta=1.0):
    """
    Returns moment equality constraints generated by the two-qubit system specified by sys.
    In particular implements the constraints p(00|xy) and p(0|x), p(0|y) for each x,y.
        sys --  parameterization of two qubit system [theta, a0, a1, b0, b1]
                where state is
                                cos(theta) |00> + sin(theta) |11>
                and measurements are given by projectors
                                (id + cos(x) sz + sin(x) sx)/2
                defined by the remaining angles in sys with sz and sx being the Pauli z
                and Pauli x matrices.
        Aops -- Operators for Alice
        Bops -- Operators for Bob
        eta  -- Detection efficiency
    """

    [id, sx, sy, sz] = [qtp.qeye(2), qtp.sigmax(), qtp.sigmay(), qtp.sigmaz()]
    [theta, a0, a1, b0, b1] = sys[:]
    # Assume a pure two-qubit state of |00> + |11> form
    rho = (cos(theta)*qtp.ket('00') + sin(theta)*qtp.ket('11')).proj()

    # Define the projectors for each of the measurements of Alice and Bob
    a00 = 0.5*(id + cos(a0)*sz + sin(a0)*sx)
    a01 = id - a00
    a10 = 0.5*(id + cos(a1)*sz + sin(a1)*sx)
    a11 = id - a10
    b00 = 0.5*(id + cos(b0)*sz + sin(b0)*sx)
    b01 = id - b00
    b10 = 0.5*(id + cos(b1)*sz + sin(b1)*sx)
    b11 = id - b10

    A_meas = [[a00, a01], [a10, a11]]
    B_meas = [[b00, b01], [b10, b11]]

    # Now collect the constraints subject to the inefficient detection distribution
    constraints = []
    # Constraints of form p(00|xy)
    for x in range(2):
        for y in range(2):
        #for y in range(3):
            constraints += [Aops[x][0]*Bops[y][0] - (eta * (rho*qtp.tensor(A_meas[x][0], B_meas[y][0])).tr().real
            + (1-eta)/4)]
    # Marginal constraints
    constraints += [Aops[0][0] - (eta) * (rho*qtp.tensor(A_meas[0][0], id)).tr().real - (1-eta)/2]
    constraints += [Bops[0][0] - (eta) * (rho*qtp.tensor(id, B_meas[0][0])).tr().real - (1-eta)/2]
    constraints += [Aops[1][0] - (eta) * (rho*qtp.tensor(A_meas[1][0], id)).tr().real - (1-eta)/2]
    constraints += [Bops[1][0] - (eta) * (rho*qtp.tensor(id, B_meas[1][0])).tr().real - (1-eta)/2]

    return constraints[:]

def sys2vec(sys, eta = 1.0):
    """
    Returns vector of probabilities p(00|xy), p(0|x), p(0|y) associated with sys in the same order
    as the constraints are specified in score_constraints function.
        sys --  parameterization of two qubit system [theta, a0, a1, b0, b1]
                where state is
                                cos(theta) |00> + sin(theta) |11>
                and measurements are given by projectors
                                (id + cos(x) sz + sin(x) sx)/2
                defined by the remaining angles in sys with sz and sx being the Pauli z
                and Pauli x matrices.
        eta  -- Detection efficiency
    """
    [id, sx, sy, sz] = [qtp.qeye(2), qtp.sigmax(), qtp.sigmay(), qtp.sigmaz()]
    [theta, a0, a1, b0, b1] = sys[:]
    rho = (cos(theta)*qtp.ket('00') + sin(theta)*qtp.ket('11')).proj()

    # Define the projectors for each of the measurements of Alice and Bob
    a00 = 0.5*(id + cos(a0)*sz + sin(a0)*sx)
    a01 = id - a00
    a10 = 0.5*(id + cos(a1)*sz + sin(a1)*sx)
    a11 = id - a10
    b00 = 0.5*(id + cos(b0)*sz + sin(b0)*sx)
    b01 = id - b00
    b10 = 0.5*(id + cos(b1)*sz + sin(b1)*sx)
    b11 = id - b10
    
    
    A_meas = [[a00, a01], [a10, a11]]
    B_meas = [[b00, b01], [b10, b11]]

    # Now collect the vector
    vec = []
    for x in range(2):
        for y in range(2):
            vec += [(eta * (rho*qtp.tensor(A_meas[x][0], B_meas[y][0])).tr().real 
                        + (1-eta)/4)]

    vec += [eta * (rho*qtp.tensor(A_meas[0][0], id)).tr().real + (1-eta)/2]
    vec += [eta * (rho*qtp.tensor(id, B_meas[0][0])).tr().real + (1-eta)/2]
    vec += [eta * (rho*qtp.tensor(A_meas[1][0], id)).tr().real + (1-eta)/2]
    vec += [eta * (rho*qtp.tensor(id, B_meas[1][0])).tr().real + (1-eta)/2]
    
    return vec      



def get_subs():
    """
    Returns any substitution rules to use with ncpol2sdpa. E.g. projections and
    commutation relations.
    """
    subs = {}
    # Get Alice and Bob's projective measurement constraints
    subs.update(ncp.projective_measurement_constraints(A,B))

    # Finally we note that Alice and Bob's operators should All commute with Eve's ops
    for a in ncp.flatten([A,B]):
        for z in ncp.flatten(Z):
            subs.update({z*a : a*z, Dagger(z)*a : a*Dagger(z)})

    return subs


def get_extra_monomials():
    """
    Returns additional monomials to add to sdp relaxation.
    """

    monos = []

    return monos[:]


    return monos[:]

def get_local_level(k):

    monos = []

    # Add ABZ
    ZZ = ncp.get_monomials(ncp.flatten(Z), k)
    AA = ncp.get_monomials(ncp.flatten(A), k)
    BB = ncp.get_monomials(ncp.flatten(B), k)

    for a in AA:
        for b in BB:
            for z in ZZ:
                monos += [a*b*z]

    return monos[:]



import numpy as np
import scipy
from math import sqrt, log2, log, pi, cos, sin
import ncpol2sdpa as ncp
from sympy.physics.quantum.dagger import Dagger
import mosek
import chaospy
import qutip as qtp

LEVEL = 5                          # NPA relaxation level
M = 4                    # Number of nodes in gaussian quadrature
alpha = 0.5          # Choose alpha for Petz-Renyi entropy
T1, W1, T2, W2 = generate_quadrature(M,alpha)     # Set 1: Nodes, weights of quadrature
VERBOSE = 2                        # If > 1 then ncpol2sdpa will also be verbose

# Description of Alice and Bobs devices (each input has 2 outputs)
A_config = [2,2]
B_config = [2,2]

# Operators in the problem Alice, Bob and Eve
A = [Ai for Ai in ncp.generate_measurements(A_config, 'A')]
B = [Bj for Bj in ncp.generate_measurements(B_config, 'B')]
Z = [ncp.generate_operators('Z'+str(k), 1, hermitian=0) for k in range(1)]


substitutions = {}            # substitutions to be made (e.g. projections)
moment_ineqs = []            # Moment inequalities (e.g. Tr[rho CHSH] >= c)
moment_eqs = []                # Moment equalities (not needed here)
op_eqs = []                    # Operator equalities (not needed here)
op_ineqs = []                # Operator inequalities (e.g. Id - A00 >= 0 -- we don't include for speed)
extra_monos = []            # Extra monomials to add to the relaxation beyond the level.


# Get the relevant substitutions
substitutions = get_subs()

# Define the moment equality constraints given by the distribution induced by sys and eta
test_sys = [pi/4, 0, pi/2,pi/4, 3*pi/4]
test_eta = 0.8245

 
score_cons = score_constraints(test_sys, A, B, test_eta)


# Get any extra monomials we wanted to add to the problem
extra_monos = get_extra_monomials()

ent = 0
obj = 0
for i in range(M):
    t1i = T1[i]
    w1i = W1[i]  
    t2i = T2[i]
    w2i = W2[i]  
    c = sin(alpha*pi)/(pi)
    F = [A[0][0], 1-A[0][0]]
    G = [B[0][0], 1-B[0][0]]
     
    obj = 0
    obj += c*F[0]*G[0]*(((2*w1i)/(1+t1i))*(Dagger(Z[0][0])*Z[0][0]))
    
    obj += c*F[1]*G[1]*w1i*(1+Z[0][0]+Dagger(Z[0][0])+Z[0][0]*Dagger(Z[0][0]))
    
    
    # Finally defining the sdp relaxation in ncpol2sdpa
    ops = ncp.flatten([A,B,Z])
    sdp = ncp.SdpRelaxation(ops, verbose = VERBOSE-1, normalized=True, parallel=0)
    sdp.get_relaxation(level = LEVEL,
    equalities = op_eqs[:],
    inequalities = op_ineqs[:],
    momentequalities = moment_eqs[:]+ score_cons[:],
    momentinequalities = moment_ineqs[:],
    objective = obj,
    substitutions = substitutions,
    extramonomials = extra_monos)

    
    sdp.solve('mosek')
    # To calculate P(a=0,b=0|x=0,y=0)
    sys_probabilities = sys2vec(test_sys, test_eta)
    ent +=sdp.dual/sys_probabilities[0]
    print(sdp.status)
    
    print(i,ent)
    
    # Due to symmetries, one may remove this part and multiply the end result by 2
    
    obj = 0

    obj += c*F[0]*G[0]*w2i*(Z[0][0]*Dagger(Z[0][0]))

    obj += c*F[1]*G[1]*(((2*w2i)/(1+t2i))*(1+Z[0][0]+Dagger(Z[0][0])+Dagger(Z[0][0])*Z[0][0]))

    


    # Finally defining the sdp relaxation in ncpol2sdpa
    ops = ncp.flatten([A,B,Z])
    sdp = ncp.SdpRelaxation(ops, verbose = VERBOSE-1, normalized=True, parallel=0)
    sdp.get_relaxation(level = LEVEL,
    equalities = op_eqs[:],
    inequalities = op_ineqs[:],
    momentequalities = moment_eqs[:]+ score_cons[:],
    momentinequalities = moment_ineqs[:],
    objective = obj,
    substitutions = substitutions,
    extramonomials = extra_monos)
    
    
    
    sdp.solve('mosek')
    ent +=sdp.dual/sys_probabilities[0]
    print(sdp.status)
    
    print(i,ent)
    
print(ent)


# Pretty Good Fidelity (i.e. alpha = 0.5)

# 0.2634895066407448 for M = 4, GL = 5, eta = .8245 (q = 8.775%, QBER = 0.208)
# eps/1-eps = 0.26341626382429323


